from __future__ import annotations

import enum
import hashlib
import io
from itertools import islice
from os import PathLike
from pathlib import Path
from typing import Iterable, NamedTuple, TextIO, Sequence
import re

import httpx


GITIGNORE_API_URL = "https://www.toptal.com/developers/gitignore/api/"
GENERATED_GUARD_START = "### START-GENERATED-CONTENT [HASH: {hash}]"
GENERATED_GUARD_START_REGEX = "### START-GENERATED-CONTENT \[HASH: (.*)\]"
GENERATED_TOKENS = "### TOKENS: {tokens}"
GENERATED_TOKEN_REGEX = "### TOKENS: (.*)"
GENERATED_GUARD_DESCRIPTION = """\
# -------------------------------------------------------------------------------------------------
# THIS SECTION WAS AUTOMATICALLY GENERATED BY KRAKEN; DO NOT MODIFY OR YOUR CHANGES WILL BE LOST.
# If you need to define custom gitignore rules, add them below
# -------------------------------------------------------------------------------------------------"""
GENERATED_GUARD_END = "### END-GENERATED-CONTENT"

DEFAULT_TOKENS = [
    # Platforms
    "macos",
    "linux",
    "windows",
    # IDEs
    "visualstudiocode",
    "vim",
    "emacs",
    "clion",
    "intellij",
    "pycharm",
    "jupyternotebooks",
    # Tooling
    "git",
    "gcov",
    "node",
    "yarn",
    # Languages
    "python",
    "rust",
    "react",
    "matlab",
]


class GitignoreEntryType(enum.Enum):
    COMMENT = enum.auto()
    BLANK = enum.auto()
    PATH = enum.auto()


class GitignoreEntry(NamedTuple):
    type: GitignoreEntryType
    value: str

    def __str__(self) -> str:
        if self.is_comment():
            return f"# {self.value}"
        return self.value

    def is_comment(self) -> bool:
        return self.type == GitignoreEntryType.COMMENT

    def is_blank(self) -> bool:
        return self.type == GitignoreEntryType.BLANK

    def is_path(self) -> bool:
        return self.type == GitignoreEntryType.PATH


class GitignoreFile:
    entries: list[GitignoreEntry]
    generated_content: str = None
    generated_content_hash: str = None
    generated_content_tokens: Sequence[str] = None

    def __init__(self, entries: list[GitignoreEntry]):
        self.entries = entries

    def find_comment(self, comment: str) -> int | None:
        return next(
            (i for i, e in enumerate(self.entries) if e.is_comment() and e.value.lstrip("#").strip() == comment), None
        )

    def paths(self, start: int | None = None, stop: int | None = None) -> Iterable[str]:
        return (entry.value for entry in islice(self.entries, start, stop) if entry.is_path())

    def add_comment(self, comment: str, index: int | None = None) -> None:
        entry = GitignoreEntry(GitignoreEntryType.COMMENT, comment)
        self.entries.insert(len(self.entries) if index is None else index, entry)

    def add_blank(self, index: int | None = None) -> None:
        entry = GitignoreEntry(GitignoreEntryType.BLANK, "")
        self.entries.insert(len(self.entries) if index is None else index, entry)

    def add_path(self, path: str, index: int | None = None) -> None:
        entry = GitignoreEntry(GitignoreEntryType.PATH, path)
        self.entries.insert(len(self.entries) if index is None else index, entry)

    def remove_path(self, path: str) -> None:
        removed = 0
        while True:
            index = next((i for i, e in enumerate(self.entries) if e.is_path() and e.value == path), None)
            if index is None:
                break
            del self.entries[index]
            removed += 1
        if removed == 0:
            raise ValueError(f'"{path}" not in GitignoreFile')

    def render(self) -> str:
        guarded_section = [
            GENERATED_GUARD_START.format(hash=self.generated_content_hash),
            self.generated_content,
            GENERATED_GUARD_END,
            "",
        ]
        user_content = map(str, self.entries)
        return "\n".join(guarded_section) + "\n" + "\n".join(user_content) + "\n"

    def refresh_generated_content(self, tokens=DEFAULT_TOKENS) -> None:
        result = httpx.get(GITIGNORE_API_URL + ",".join(tokens))
        # TODO(david): error handling / nice task status erros
        assert result.status_code == 200
        self.generated_content_tokens = tokens
        self.generated_content = "\n".join([
            GENERATED_GUARD_DESCRIPTION,
            GENERATED_TOKENS.format(tokens=", ".join(self.generated_content_tokens)),
            "",
            result.text,
            "# -------------------------------------------------------------------------------------------------"
        ])

    def refresh_hash(self) -> None:
        self.generated_content_hash = hashlib.sha256(self.generated_content.encode("utf-8")).hexdigest()
        print('refresh_hash:', self.generated_content)

    def validate_tokens(self, tokens=DEFAULT_TOKENS) -> bool:  # TODO(david): revise naming
        return self.generated_content_tokens == tokens

    def validate_generated_content_hash(self) -> bool:
        print('generated_content_hash', self.generated_content_hash)
        print('hashlib               ',
              hashlib.sha256(self.generated_content.encode("utf-8")).hexdigest())
        print('validating  :', self.generated_content)
        return self.generated_content_hash == hashlib.sha256(self.generated_content.encode("utf-8")).hexdigest()

    def sort_gitignore(self, sort_paths: bool = True, sort_groups: bool = False) -> GitignoreFile:
        """Sorts the entries in the specified gitignore file, keeping paths under a common comment block grouped.
        Will also get rid of any extra blanks.

        :param gitignore: The input to sort.
        :param sort_paths: Whether to sort paths (default: True).
        :param sort_groups: Whether to sort groups among themselves, not just paths within groups (default: False).
        :return: A new, sorted gitignore file.
        """

        class Group(NamedTuple):
            comments: list[str]
            paths: list[str]

        # List of (comments, paths).
        groups: list[Group] = [Group([], [])]

        for entry in self.entries:
            if entry.is_path():
                groups[-1].paths.append(entry.value)
            elif entry.is_comment():
                # If we already have paths in the current group, we open a new group.
                if groups[-1].paths:
                    groups.append(Group([entry.value], []))
                # Otherwise we append the comment to the group.
                else:
                    groups[-1].comments.append(entry.value)

        if sort_groups:
            groups.sort(key=lambda g: "\n".join(g.comments).lower())

        self.entries = []
        for group in groups:
            if sort_paths:
                group.paths.sort(key=str.lower)
            for comment in group.comments:
                self.add_comment(comment)
            for path in group.paths:
                self.add_path(path)
            self.add_blank()

        if self.entries and self.entries[-1].is_blank():
            self.entries.pop()


def parse_gitignore(file: TextIO | Path | str) -> GitignoreFile:
    if isinstance(file, str):
        return parse_gitignore(io.StringIO(file))
    elif isinstance(file, PathLike):
        with file.open() as fp:
            return parse_gitignore(fp)

    gitignore = GitignoreFile([])
    inside_guard = False
    generated_content = []
    for line in file:
        line = line.rstrip("\n")  # TODO(david) this creates hash mismatches
        if match := re.match(GENERATED_GUARD_START_REGEX, line):
            gitignore.generated_content_hash = match.group(1)
            inside_guard = True
        elif line == GENERATED_GUARD_END:
            inside_guard = False
            gitignore.generated_content = "\n".join(generated_content)
        elif inside_guard:
            generated_content += [line]
            if token_match := re.match(GENERATED_TOKEN_REGEX, line):
                gitignore.generated_content_tokens = token_match.group(1).split(", ")
        elif line.startswith("#"):
            gitignore.entries.append(GitignoreEntry(GitignoreEntryType.COMMENT, line[1:].lstrip()))
        elif not line.strip():
            gitignore.entries.append(GitignoreEntry(GitignoreEntryType.BLANK, ""))
        else:
            gitignore.entries.append(GitignoreEntry(GitignoreEntryType.PATH, line))

    return gitignore
