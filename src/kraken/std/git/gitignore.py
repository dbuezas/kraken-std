from __future__ import annotations

import enum
import hashlib
import io
from itertools import islice
from os import PathLike
from pathlib import Path
from typing import Iterable, NamedTuple, TextIO, Sequence
import re

import httpx


GITIGNORE_API_URL = "https://www.toptal.com/developers/gitignore/api/"
GENERATED_GUARD_START = "### START-GENERATED-CONTENT [HASH: {hash}]"
GENERATED_GUARD_START_REGEX = "### START-GENERATED-CONTENT \[HASH: (?<hash>.*)\]"
GENERATED_TOKEN_REGEX = "### TOKENS: \[(.*)\]"
GENERATED_GUARD_DESCRIPTION = """\
#
# THIS SECTION WAS AUTOMATICALLY GENERATED BY KRAKEN; DO NOT MODIFY OR YOUR CHANGES WILL BE LOST.
# If you need to define custom gitignore rules, add them below
#
"""
GENERATED_GUARD_END = "### END-GENERATED-CONTENT"

DEFAULT_TOKENS = [
    # Platforms
    'macos',
    'linux',
    'windows',
    # IDEs
    'visualstudiocode',
    'vim',
    'emacs',
    'clion',
    'intellij',
    'pycharm',
    'jupyternotebooks',
    # Tooling
    'git',
    'gcov',
    'node',
    'yarn',
    # Languages
    'python',
    'rust',
    'react',
    'matlab'
]


class GitignoreEntryType(enum.Enum):
    COMMENT = enum.auto()
    BLANK = enum.auto()
    PATH = enum.auto()


class GitignoreEntry(NamedTuple):
    type: GitignoreEntryType
    value: str

    def __str__(self) -> str:
        if self.is_comment():
            return f"# {self.value}"
        return self.value

    def is_comment(self) -> bool:
        return self.type == GitignoreEntryType.COMMENT

    def is_blank(self) -> bool:
        return self.type == GitignoreEntryType.BLANK

    def is_path(self) -> bool:
        return self.type == GitignoreEntryType.PATH


class GitignoreFile(NamedTuple):
    entries: list[GitignoreEntry]
    generated_content: str
    generated_content_hash: str
    generated_content_tokens: Sequence[str]
    # TODO(david-luke): ch2     - generated_content_hash
    # TODO(david-luke): ch2     - generated_content_token_list
    # TODO(david-luke): ch2     - generated_content_hash

    # TODO(david-luke): ch2     - refresh_gen_content
    # TODO(david-luke): ch2     - refresh_gen_content_hash
    # TODO(david-luke): ch2     - fn to validate the hash
    # TODO(david-luke): ch2     - also compare the token list to the input.

    def find_comment(self, comment: str) -> int | None:
        return next(
            (i for i, e in enumerate(self.entries) if e.is_comment() and e.value.lstrip("#").strip() == comment), None
        )

    def paths(self, start: int | None = None, stop: int | None = None) -> Iterable[str]:
        return (entry.value for entry in islice(self.entries, start, stop) if entry.is_path())

    def add_comment(self, comment: str, index: int | None = None) -> None:
        entry = GitignoreEntry(GitignoreEntryType.COMMENT, comment)
        self.entries.insert(len(self.entries) if index is None else index, entry)

    def add_blank(self, index: int | None = None) -> None:
        entry = GitignoreEntry(GitignoreEntryType.BLANK, "")
        self.entries.insert(len(self.entries) if index is None else index, entry)

    def add_path(self, path: str, index: int | None = None) -> None:
        entry = GitignoreEntry(GitignoreEntryType.PATH, path)
        self.entries.insert(len(self.entries) if index is None else index, entry)

    def remove_path(self, path: str) -> None:
        removed = 0
        while True:
            index = next((i for i, e in enumerate(self.entries) if e.is_path() and e.value == path), None)
            if index is None:
                break
            del self.entries[index]
            removed += 1
        if removed == 0:
            raise ValueError(f'"{path}" not in GitignoreFile')

    def render(self) -> str:
        return "\n".join(map(str, self.entries)) + "\n"

    def refresh_generated_content(self, tokens=DEFAULT_TOKENS) -> None:
        result = httpx.get(GITIGNORE_API_URL + tokens.join(','))
        # TODO(david): error handling / nice task status erros
        assert (result.status_code == 200)

        # TODO(david): A bit to much reliance on side effects. Review.
        self.generated_content_tokens = tokens
        self.generated_content = result.text

    def refresh_hash(self) -> None:
        self.generated_content_hash = hashlib.sha256(self.generated_content)

    def validate_generated_content(self, tokens=DEFAULT_TOKENS) -> bool:
        hash_match = self.generated_content_tokens == tokens
        tokens_match = self.generated_content_hash == hashlib.sha256(self.generated_content)
        return hash_match and tokens_match


def parse_gitignore(file: TextIO | Path | str) -> GitignoreFile:
    if isinstance(file, str):
        return parse_gitignore(io.StringIO(file))
    elif isinstance(file, PathLike):
        with file.open() as fp:
            return parse_gitignore(fp)

    gitignore = GitignoreFile([])
    inside_guard = False
    generated_content = []
    for line in file:
        line = line.rstrip("\n")
        if match := re.match(GENERATED_GUARD_START_REGEX, line):
            gitignore.generated_hash = match.group(1)
            inside_guard = True
        elif line == GENERATED_GUARD_END:
            inside_guard = False
            gitignore.generated_content = generated_content.join('\n')
        elif inside_guard:
            generated_content += [line]
            if token_match := re.match(GENERATED_TOKEN_REGEX, line):
                gitignore.generated_content_tokens = token_match.group(1).split(', ')
        elif line.startswith("#"):
            gitignore.entries.append(GitignoreEntry(GitignoreEntryType.COMMENT, line[1:].lstrip()))
        elif not line.strip():
            gitignore.entries.append(GitignoreEntry(GitignoreEntryType.BLANK, ""))
        else:
            gitignore.entries.append(GitignoreEntry(GitignoreEntryType.PATH, line))

    return gitignore


def sort_gitignore(gitignore: GitignoreFile, sort_paths: bool = True, sort_groups: bool = False) -> GitignoreFile:
    """Sorts the entries in the specified gitignore file, keeping paths under a common comment block grouped.
    Will also get rid of any extra blanks.

    :param gitignore: The input to sort.
    :param sort_paths: Whether to sort paths (default: True).
    :param sort_groups: Whether to sort groups among themselves, not just paths within groups (default: False).
    :return: A new, sorted gitignore file.
    """

    class Group(NamedTuple):
        comments: list[str]
        paths: list[str]

    # List of (comments, paths).
    groups: list[Group] = [Group([], [])]

    for entry in gitignore.entries:
        if entry.is_path():
            groups[-1].paths.append(entry.value)
        elif entry.is_comment():
            # If we already have paths in the current group, we open a new group.
            if groups[-1].paths:
                groups.append(Group([entry.value], []))
            # Otherwise we append the comment to the group.
            else:
                groups[-1].comments.append(entry.value)

    if sort_groups:
        groups.sort(key=lambda g: "\n".join(g.comments).lower())

    new = GitignoreFile([])
    for group in groups:
        if sort_paths:
            group.paths.sort(key=str.lower)
        for comment in group.comments:
            new.add_comment(comment)
        for path in group.paths:
            new.add_path(path)
        new.add_blank()

    if new.entries and new.entries[-1].is_blank():
        new.entries.pop()

    return new
